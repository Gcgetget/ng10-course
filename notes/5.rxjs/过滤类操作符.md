## audit
在定时器发出值之前，会忽略所有源Observable发出的值，直到定时器发出值，会推送源Observable最近发出的一次值
```typescript
const clicks = fromEvent(document, 'click').pipe(pluck('clientX'));
const result = clicks.pipe(audit(ev => interval(2000)));
result.subscribe(x => console.log(x));
```
## auditTime
类似audit，上例可重写为
```typescript
const clicks = fromEvent(document, 'click').pipe(pluck('clientX'));
const result = clicks.pipe(auditTime(2000));
result.subscribe(x => console.log(x));
```

## debounce
当源Observable的发射间隔大于指定timer时，才会发出最近的一次值
<br>
与audit的区别是：
- audit是否发出值取决于timer是否发出值
- debounce是否发出值取决源Observable的发射间隔是否大于给定的timer
```typescript
const clicks = fromEvent(document, 'click');
const result = clicks.pipe(debounce(() => interval(1000)));
result.subscribe(x => console.log(x));
```

## debounceTime
类似debounce，上例可重写为

```typescript
const clicks = fromEvent(document, 'click');
const result = clicks.pipe(debounceTime(1000));
result.subscribe(x => console.log(x));
```

##  distinct
依次发出源Observable的值，只是每次只发出与之前不同的值(或者之前从没出现过的值)
```typescript
of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1).pipe(distinct()).subscribe(x => console.log(x)); // 1, 2, 3, 4
```
还可以指定过滤函数
```typescript
interface Person {
   age: number,
   name: string
}
of<Person>(
  { age: 4, name: 'Foo'},
  { age: 7, name: 'Bar'},
  { age: 5, name: 'Foo'},
).pipe(
  distinct((p: Person) => p.name),
)
.subscribe(x => console.log(x));
```

## distinctUntilChanged
当源Observable发出了与上一次不同的值时，才把当前值推送出去
```typescript
of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4).pipe(distinctUntilChanged())
  .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
```
还可以指定过滤函数
```typescript
interface Person {
   age: number,
   name: string
}
 
of<Person>(
    { age: 4, name: 'Foo'},
    { age: 7, name: 'Bar'},
    { age: 5, name: 'Foo'},
    { age: 6, name: 'Foo'},
  ).pipe(
    distinctUntilChanged((p: Person, q: Person) => p.name === q.name),
  )
  .subscribe(x => console.log(x));
```

## distinctUntilKeyChanged
当源Observable发出的值，它的key与上一次值的key不同时，才把当前值推送出去
```typescript
import { of } from 'rxjs';
import { distinctUntilKeyChanged } from 'rxjs/operators';

 interface Person {
    age: number,
    name: string
 }

of<Person>(
    { age: 4, name: 'Foo'},
    { age: 7, name: 'Bar'},
    { age: 5, name: 'Foo'},
    { age: 6, name: 'Foo'},
  ).pipe(
    distinctUntilKeyChanged('name'),
  )
  .subscribe(x => console.log(x));
```

更精细的匹配
```typescript
import { of } from 'rxjs';
import { distinctUntilKeyChanged } from 'rxjs/operators';

interface Person {
    age: number,
    name: string
 }

of<Person>(
    { age: 4, name: 'Foo1'},
    { age: 7, name: 'Bar'},
    { age: 5, name: 'Foo2'},
    { age: 6, name: 'Foo3'},
  ).pipe(
    distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3)),
  )
  .subscribe(x => console.log(x));
```

## elementAt
发出指定索引的那个值
```typescript
const clicks = fromEvent(document, 'click');
const result = clicks.pipe(elementAt(2));
result.subscribe(x => console.log(x));
```

## ignoreElements
忽略源Observable发出的所有值，直接complete
```typescript
of('you', 'talking', 'to', 'me').pipe(ignoreElements())
    .subscribe(
      word => console.log(word),
      err => console.log('error:', err),
      () => console.log('the end'
    );
```

## filter
类似数组的filter
```typescript
import { fromEvent } from 'rxjs';
import { filter } from 'rxjs/operators';

const clicks = fromEvent(document, 'click');
const clicksOnDivs = clicks.pipe(filter(ev => ev.target.tagName === 'DIV'));
clicksOnDivs.subscribe(x => console.log(x));
```

## first
只取第一个发出的值
```typescript
import { fromEvent } from 'rxjs';
import { first } from 'rxjs/operators';

const clicks = fromEvent(document, 'click');
const result = clicks.pipe(first());
result.subscribe(x => console.log(x));
```

也可以指定第一个值符合的条件
```typescript
import { fromEvent } from 'rxjs';
import { first } from 'rxjs/operators';

const clicks = fromEvent(document, 'click');
const result = clicks.pipe(first(ev => ev.target.tagName === 'DIV'));
result.subscribe(x => console.log(x));
```



## last
只取最后一个值
```typescript
of('you', 'talking', 'to', 'me').pipe(last()).subscribe(res => console.log(res));
```
